import { exit } from 'process';
import { MSVCVector } from './msvc.js'

const baseAddr = Process.enumerateModules()[0].base;
const baseSize = Process.enumerateModules()[0].size;

let procVceBlockEncryptBlowfishCtor: any = null

// A terrible global object to keep references to all allocated memory
// this _should_ be cleared once we are done with our allocs, however,
// due to the limited usage of this library, we just allow the memory to
// leak until to the process we are injected into restarts.
let pinned_allocs = new Map();
function customAlloc(size: number): NativePointer {
    let mem = Memory.alloc(size);
    pinned_allocs.set(mem, mem);
    return mem;
}

function customDealloc(ptr: NativePointer): void {
    pinned_allocs.delete(ptr);
}

rpc.exports = {
    initAgent: function(): boolean {
        // We use the following pattern to find the address of the vce::BlockEncryptBlowfish::ctor function.
        // We don't use the actual function start, as that is obfuscated code generated by the packer 
        // which will change on each update.
        // .text:012FBD01 6A 0C                                                        push    0Ch
        // .text:012FBD03 6A 0C                                                        push    0Ch
        // .text:012FBD05 E8 86 1B 84 FF                                               call    alloc_mem
        // .text:012FBD0A 83 C4 08                                                     add     esp, 8
        // .text:012FBD0D 85 C0                                                        test    eax, eax
        // .text:012FBD0F 74 10                                                        jz      short loc_12FBD21
        // .text:012FBD11 6A 00                                                        push    0
        // .text:012FBD13 8B C8                                                        mov     ecx, eax        ; this
        // .text:012FBD15 E8 F6 07 1D 00                                               call    vce__BlockEncryptBlowfish__ctor
        const pattern = "6A 0C 6A 0C E8 ?? ?? ?? ?? 83 C4 08 85 C0 74 ?? 6A 00 ?? ?? E8";
        const patternScanResults = Memory.scanSync(baseAddr, baseSize, pattern);
        if(patternScanResults.length != 1) {
            console.log("Failed to pattern match for vce::BlockEncryptBlowfish::ctor.")
            return false;
        }

        // The x86 call instruction used is the `E8 cd`/CALL rel32 variant, so we need to calculate the address.
        const callInstructionAddress = patternScanResults[0].address.add(0x14); // `call` inst is +0x14 from our pattern start.
        const vceBlockEncryptBlowfishCtorAddress = callInstructionAddress
            .add(1) // The relative address is after the E8 byte.
            .readPointer() // Now we have the offset relative to the next instruction
            .add(callInstructionAddress.add(5)); // Add the rel offset to the address of the next instruction (`call` is 5 bytes)

        console.log("Found vce::BlockEncryptBlowfish::ctor @ " + vceBlockEncryptBlowfishCtorAddress);

        procVceBlockEncryptBlowfishCtor = new NativeFunction(vceBlockEncryptBlowfishCtorAddress, 'pointer', ['pointer'], 'thiscall');

        return true;
    },
    blowfishDecrypt: function(key: string, data_arr: Array<number>): ArrayBuffer {
        let data = new Uint8Array(data_arr).buffer as ArrayBuffer;

        let blowfishObjMemory = customAlloc(12);
        let blowfishObj = procVceBlockEncryptBlowfishCtor(blowfishObjMemory);
        let vtable = blowfishObj.readPointer();

        /* Load the vtable functions...
        0x00 + j_vce__BlockEncryptBlowfish__dtor
        0x04 + vce__BlockEncryptBlowfish__Initialize // bool Initialize(unsigned char *key,int keybitlength);
        0x08 + vce__BlockEncryptBlowfish__Reinitialize // bool Reinitialize();
        0x0C + vce__BlockEncryptBlowfish__Encrypt // bool Encrypt(const void *src,size_t srcsize,std::vector<unsigned char> &dest);
        0x10 + vce__BlockEncryptBlowfish__Decrypt // bool Decrypt(const std::vector<unsigned char> &src,std::vector<unsigned char> &dest);
        */

        let vf_vce_initalize = new NativeFunction(vtable.add(0x04).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'int'], 'thiscall');
        let vf_vce_reinitalize = new NativeFunction(vtable.add(0x08).readPointer(), 'bool', [], 'thiscall');
        let vf_vce_encrypt = new NativeFunction(vtable.add(0x0C).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'pointer'], 'thiscall');
        let vf_vce_decrypt = new NativeFunction(vtable.add(0x10).readPointer(), 'bool', ['pointer', 'pointer', 'pointer'], 'thiscall');

        let keyMem = customAlloc(key.length);
        keyMem.writeAnsiString(key);

        let result = vf_vce_initalize(blowfishObj, keyMem, 8*key.length, 0);

        let src = new MSVCVector(customAlloc, customDealloc);
        src.setData(data);

        let dst = new MSVCVector(customAlloc, customDealloc);
        dst.resize(data.byteLength);
        
        let result2 = vf_vce_decrypt(blowfishObj, src.ptr(), dst.ptr());

        // Recalculate this in case the encryption changed the size somehow (padding, etc)
        let outputSize = dst.size();
        return dst.get_start().readByteArray(outputSize)!;
    },
    blowfishEncrypt: function(key: string, data_arr: Array<number>): ArrayBuffer {
        let data = new Uint8Array(data_arr).buffer as ArrayBuffer;

        let blowfishObjMemory = customAlloc(12);
        let blowfishObj = procVceBlockEncryptBlowfishCtor(blowfishObjMemory);
        let vtable = blowfishObj.readPointer();

        /* Load the vtable functions...
        0x00 + j_vce__BlockEncryptBlowfish__dtor
        0x04 + vce__BlockEncryptBlowfish__Initialize // bool Initialize(unsigned char *key,int keybitlength);
        0x08 + vce__BlockEncryptBlowfish__Reinitialize // bool Reinitialize();
        0x0C + vce__BlockEncryptBlowfish__Encrypt // bool Encrypt(const void *src,size_t srcsize,std::vector<unsigned char> &dest);
        0x10 + vce__BlockEncryptBlowfish__Decrypt // bool Decrypt(const std::vector<unsigned char> &src,std::vector<unsigned char> &dest);
        */

        let vf_vce_initalize = new NativeFunction(vtable.add(0x04).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'int'], 'thiscall');
        let vf_vce_reinitalize = new NativeFunction(vtable.add(0x08).readPointer(), 'bool', [], 'thiscall');
        let vf_vce_encrypt = new NativeFunction(vtable.add(0x0C).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'pointer'], 'thiscall');
        let vf_vce_decrypt = new NativeFunction(vtable.add(0x10).readPointer(), 'bool', ['pointer', 'pointer', 'pointer'], 'thiscall');

        let keyMem = customAlloc(key.length);
        keyMem.writeAnsiString(key);

        let result = vf_vce_initalize(blowfishObj, keyMem, 8*key.length, 0);

        let srcMem = customAlloc(data.byteLength);
        srcMem.writeByteArray(data);

        let dst = new MSVCVector(customAlloc, customDealloc);
        dst.resize(8* (((data.byteLength+7)>>3)+4));

        let result2 = vf_vce_encrypt(blowfishObj, srcMem, data.byteLength, dst.ptr());

        // Recalculate this in case the encryption changed the size somehow (padding, etc)
        let outputSize = dst.size();
        return dst.get_start().readByteArray(outputSize)!;
    }
}