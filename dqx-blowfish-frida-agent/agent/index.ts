import { exit } from 'process';
import { MSVCVector } from './msvc.js'
import HWBP from './hwbp.js'

const baseAddr = Process.enumerateModules()[0].base;
const baseSize = Process.enumerateModules()[0].size;

let procVceBlockEncryptBlowfishCtor: any = null
let currentHashCallType: string
let currentHashCallInput: string

// A terrible global object to keep references to all allocated memory
// this _should_ be cleared once we are done with our allocs, however,
// due to the limited usage of this library, we just allow the memory to
// leak until to the process we are injected into restarts.
let pinned_allocs = new Map();
function customAlloc(size: number): NativePointer {
    let mem = Memory.alloc(size);
    pinned_allocs.set(mem, mem);
    return mem;
}

function customDealloc(ptr: NativePointer): void {
    pinned_allocs.delete(ptr);
}

rpc.exports = {
    initAgent: function(): boolean {
        // We use the following pattern to find the address of the vce::BlockEncryptBlowfish::ctor function.
        // We don't use the actual function start, as that is obfuscated code generated by the packer 
        // which will change on each update.
        // .text:012FBD01 6A 0C                                                        push    0Ch
        // .text:012FBD03 6A 0C                                                        push    0Ch
        // .text:012FBD05 E8 86 1B 84 FF                                               call    alloc_mem
        // .text:012FBD0A 83 C4 08                                                     add     esp, 8
        // .text:012FBD0D 85 C0                                                        test    eax, eax
        // .text:012FBD0F 74 10                                                        jz      short loc_12FBD21
        // .text:012FBD11 6A 00                                                        push    0
        // .text:012FBD13 8B C8                                                        mov     ecx, eax        ; this
        // .text:012FBD15 E8 F6 07 1D 00                                               call    vce__BlockEncryptBlowfish__ctor
        const pattern = "6A 0C 6A 0C E8 ?? ?? ?? ?? 83 C4 08 85 C0 74 ?? 6A 00 ?? ?? E8";
        const patternScanResults = Memory.scanSync(baseAddr, baseSize, pattern);
        if(patternScanResults.length != 1) {
            console.log("Failed to pattern match for vce::BlockEncryptBlowfish::ctor.")
            return false;
        }

        // The x86 call instruction used is the `E8 cd`/CALL rel32 variant, so we need to calculate the address.
        const callInstructionAddress = patternScanResults[0].address.add(0x14); // `call` inst is +0x14 from our pattern start.
        const vceBlockEncryptBlowfishCtorAddress = callInstructionAddress
            .add(1) // The relative address is after the E8 byte.
            .readPointer() // Now we have the offset relative to the next instruction
            .add(callInstructionAddress.add(5)); // Add the rel offset to the address of the next instruction (`call` is 5 bytes)

        // console.log("Found vce::BlockEncryptBlowfish::ctor @ " + vceBlockEncryptBlowfishCtorAddress);

        procVceBlockEncryptBlowfishCtor = new NativeFunction(vceBlockEncryptBlowfishCtorAddress, 'pointer', ['pointer'], 'thiscall'); 

        return true;
    },
    blowfishDecrypt: function(key: string, data_arr: Array<number>): ArrayBuffer {
        let data = new Uint8Array(data_arr).buffer as ArrayBuffer;

        let blowfishObjMemory = customAlloc(12);
        let blowfishObj = procVceBlockEncryptBlowfishCtor(blowfishObjMemory);
        let vtable = blowfishObj.readPointer();

        /* Load the vtable functions...
        0x00 + j_vce__BlockEncryptBlowfish__dtor
        0x04 + vce__BlockEncryptBlowfish__Initialize // bool Initialize(unsigned char *key,int keybitlength);
        0x08 + vce__BlockEncryptBlowfish__Reinitialize // bool Reinitialize();
        0x0C + vce__BlockEncryptBlowfish__Encrypt // bool Encrypt(const void *src,size_t srcsize,std::vector<unsigned char> &dest);
        0x10 + vce__BlockEncryptBlowfish__Decrypt // bool Decrypt(const std::vector<unsigned char> &src,std::vector<unsigned char> &dest);
        */

        let vf_vce_initalize = new NativeFunction(vtable.add(0x04).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'int'], 'thiscall');
        let vf_vce_reinitalize = new NativeFunction(vtable.add(0x08).readPointer(), 'bool', [], 'thiscall');
        let vf_vce_encrypt = new NativeFunction(vtable.add(0x0C).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'pointer'], 'thiscall');
        let vf_vce_decrypt = new NativeFunction(vtable.add(0x10).readPointer(), 'bool', ['pointer', 'pointer', 'pointer'], 'thiscall');

        let keyMem = customAlloc(key.length);
        keyMem.writeAnsiString(key);

        let result = vf_vce_initalize(blowfishObj, keyMem, 8*key.length, 0);

        let src = new MSVCVector(customAlloc, customDealloc);
        src.setData(data);

        let dst = new MSVCVector(customAlloc, customDealloc);
        dst.resize(data.byteLength);
        
        let result2 = vf_vce_decrypt(blowfishObj, src.ptr(), dst.ptr());

        // Recalculate this in case the encryption changed the size somehow (padding, etc)
        let outputSize = dst.size();
        return dst.get_start().readByteArray(outputSize)!;
    },
    blowfishEncrypt: function(key: string, data_arr: Array<number>): ArrayBuffer {
        let data = new Uint8Array(data_arr).buffer as ArrayBuffer;

        let blowfishObjMemory = customAlloc(12);
        let blowfishObj = procVceBlockEncryptBlowfishCtor(blowfishObjMemory);
        let vtable = blowfishObj.readPointer();

        /* Load the vtable functions...
        0x00 + j_vce__BlockEncryptBlowfish__dtor
        0x04 + vce__BlockEncryptBlowfish__Initialize // bool Initialize(unsigned char *key,int keybitlength);
        0x08 + vce__BlockEncryptBlowfish__Reinitialize // bool Reinitialize();
        0x0C + vce__BlockEncryptBlowfish__Encrypt // bool Encrypt(const void *src,size_t srcsize,std::vector<unsigned char> &dest);
        0x10 + vce__BlockEncryptBlowfish__Decrypt // bool Decrypt(const std::vector<unsigned char> &src,std::vector<unsigned char> &dest);
        */

        let vf_vce_initalize = new NativeFunction(vtable.add(0x04).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'int'], 'thiscall');
        let vf_vce_reinitalize = new NativeFunction(vtable.add(0x08).readPointer(), 'bool', [], 'thiscall');
        let vf_vce_encrypt = new NativeFunction(vtable.add(0x0C).readPointer(), 'bool', ['pointer', 'pointer', 'int', 'pointer'], 'thiscall');
        let vf_vce_decrypt = new NativeFunction(vtable.add(0x10).readPointer(), 'bool', ['pointer', 'pointer', 'pointer'], 'thiscall');

        let keyMem = customAlloc(key.length);
        keyMem.writeAnsiString(key);

        let result = vf_vce_initalize(blowfishObj, keyMem, 8*key.length, 0);

        let srcMem = customAlloc(data.byteLength);
        srcMem.writeByteArray(data);

        let dst = new MSVCVector(customAlloc, customDealloc);
        dst.resize(8* (((data.byteLength+7)>>3)+4));

        let result2 = vf_vce_encrypt(blowfishObj, srcMem, data.byteLength, dst.ptr());

        // Recalculate this in case the encryption changed the size somehow (padding, etc)
        let outputSize = dst.size();
        return dst.get_start().readByteArray(outputSize)!;
    },
    installBlowfishLogger: function(): boolean {
        console.log("Installing blowfish logger")

        const packageLoadPattern = "55 8B EC 53 57 8B F9 83 7F 24 00 74 ?? 83 7D 08 00";
        const patternScanResults = Memory.scanSync(baseAddr, baseSize, packageLoadPattern);
        if(patternScanResults.length != 1) {
            console.log("Failed to pattern match for unknown_decryptor::do_decrypt");
            return false;
        }

        const bp = HWBP.attach(patternScanResults[0].address, onCall => {
            let fileDataPtr = onCall.context.sp.add(0x04).readPointer();
            let blowfishKey = onCall.context.sp.add(0x08).readPointer().readAnsiString();
            let fileSize = onCall.context.sp.add(0x0C).readU32();
            let filepath = onCall.context.sp.add(0x10).readPointer().readAnsiString();
            send({message_type:'log', log_type:'bflog', filepath:filepath, file_size:fileSize, blowfish_key:blowfishKey});
            //console.log(`[BFLOG] Path:${filepath}, FileSize:${fileSize}, Key:${blowfishKey}`)
        })
        

        // // At first hash call with full path string
        // const dirHashbp = HWBP.attach(baseAddr.add(0x5dea3), onCall => {
        //     let dir = onCall.context.sp.readPointer().readAnsiString();
        //     console.log(`[HASHLOG] Dir: ${dir}`)
        // })

        // // after first hash call
        // const afterDirHashBp = HWBP.attach(baseAddr.add(0x5dea8), onCall => {
        //     const ctx = onCall.context as Ia32CpuContext;
        //     let dirHash = ctx.eax;
        //     console.log(`[HASHLOG] Dir Hash: ${dirHash}`)
        // })
        // // after second hash call (that uses only filename)
        // const afterFileHashBp = HWBP.attach(baseAddr.add(0x5deb5), onCall => {
        //     const ctx = onCall.context as Ia32CpuContext;
        //     let dirHash = ctx.eax;
        //     console.log(`[HASHLOG] File Hash: ${dirHash}`)
        // })

        // const packageLoadPattern = "55 8B EC 51 53 56 8B F1 57 8B 4E 08 85 C9 74 ?? 8B 01 6A 01";
        // const patternScanResults = Memory.scanSync(baseAddr, baseSize, packageLoadPattern);
        // if(patternScanResults.length != 1) {
        //     console.log("Failed to pattern match for SML::text::EventReader::package::Load");
        //     return false;
        // }

        // const bp = HWBP.attach(patternScanResults[0].address, onCall => {
        //     let filepath = onCall.context.sp.add(0x4).readPointer().readAnsiString();
        //     let blowfish_key = onCall.context.sp.add(0x8).readPointer().readAnsiString();
        //     console.log(`[BFLOG] Path: \"${filepath}\", Key:\"${blowfish_key}\"`)
        // })

        // Log SML::protocol::session::RequesterSessionCutSceneZoneClient Server->Client response packets
        // including blowfish key for cutscene.
        // const bp = HWBP.attach(baseAddr.add(0xc37680), onCall => {
        //     let cut_scene_load_resp = onCall.context.sp.add(0x18).readPointer();
        //     let cutscene_id = cut_scene_load_resp.add(0xC).readAnsiString();
        //     let blowfish_key = cut_scene_load_resp.add(0x27).readAnsiString();
        //     console.log("SML::protocol::session::RequesterSessionCutSceneZoneClient::vf27 - cutscene_id:" + cutscene_id + ", blowfish_key:" + blowfish_key);
        //     bp.detach()
        // })
        return true;
    },
    installHashLogger: function(): boolean {
        console.log("Installing hash logger")

        // TODO(Andoryuuta): Pattern scan these two addresses before release.
        const hashStringBp = HWBP.attach(baseAddr.add(0x5ECD0), onCall => {
            let rawString = onCall.context.sp.add(0x04).readPointer().readAnsiString();
            let usedLength = onCall.context.sp.add(0x08).readU32();

            if (rawString?.length == usedLength) {
                currentHashCallType = "file";
            } else {
                currentHashCallType = "dir";
            }

            currentHashCallInput = rawString?.slice(0, usedLength)!;
        })

        const hashStringEndBp = HWBP.attach(baseAddr.add(0x5ee82), onCall => {
            const ctx = onCall.context as Ia32CpuContext;
            let hash = ctx.eax;
            //console.log(`[HASHLOG] Type:${currentHashCallType}, String:${currentHashCallInput}, Hash: ${hash}`);
            send({message_type:'log', log_type:'hashlog', hash_type:currentHashCallType, hash_input:currentHashCallInput, hash_output:hash});
        })

        return true;
    }
}